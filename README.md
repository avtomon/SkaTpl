SkaTpl
======

SkaTpl - класс-шаблонизатор для PHP. Проще говоря, при помоще его методов можно автоматизированно наполнять HTML-шаблоны данными производя на свет, тем самым, самые настоящие HTML-страницы!

##Механика работы

Предположим вы желаете всунуть на сайт каталог товаров. В простейшем случае вам понадобится страница списка товаров и страница, собственно товара.

И так, вам надо сверстать 2 этих страницы, а затем расставить маркеры для шаблонизатора дабы он знал в какие места страницы нужно вставлять данные. 

Сейчас я как смогу поведаю суть работы шаблонизатора на примере этих страниц. Работа по поиску мест для вставки сводится к поиску определенных классов элемента в верстке, например элемент с классом *in_text_content* говорит о том что внутрь этого элемента нужно вставить содержимое поля данных content:

    <div class="in_text_content"></div>
    
    Код 1.
    
То есть должен получиться список пользователей. 
Но в изначальном шаблоне будет что-то типа:

    <li class="clone in_id_id in_data-val_birthdate">
        <span class="in_text_surname"></span>
        <span class="in_text_name"></span>
    </li>
    
    Код 4.
    
Отличие в наличие класса *clone*, строго говоря, называться он может и по-другому, но его назначение крайне важно. Класс должен нести с собой стиль CSS делающий элемент с этим классом невидимым.

Назначение же его в том, чтобы отделять элементы для множественной ставки от элементов для единичной вставки. Разница между этими двумя типами в способе обработки данных с несколькими однородными записями: при единичной вставки шаблонизатору все равно сколько записей пришло а вход, он всегда оставляет только одну – первую, то есть если воспользовался предыдущим примером с юзерами, то при единичной вставке вставится только одна первая запись о пользователе John Smith, а вторая будет отброшена. При этом должен использоваться [Код 3] (без указать класса *clone*), то есть блок [Код 3] просто заполнится данными.

Если же используется множественная вставка то будут вставлены все записи и вот как это произойдет:

1.  Шаблонизатор скопирует эталонный блок верстки код 4 (с классом *clone*) и вставит после.

2.	Вставит первый кортеж данных в эту самую копию.

3.	Пункты 1 и 2 будут повторяться пока записи данных не закончатся.

Шаблонизатор не дает методов явного выбора одного из типов ставки, здесь всегда все определяется наличием или отсутствием *HIDE_CLASS* (он же *clone* из предыдущего примера, *HIDE_CLASS* имя константы определяющей имя этого ключевого класса), для обоих типов вставки используется метод *parseResponse*.

Вернемся к HTML-шаблонам. Что же нужно сделать чтобы наполнить шаблон данными и показать в браузере?

1.  Получить данные. Данные можно получить выполнив метод одного из классов ядра системы или создав свой класс с методами возвращающими данные виде массива и выполнить один из них. Выполняются запросы методом *Service::executeRequest (array & $params)*, который получает на входе массив с именем класса, именем метода, а так же параметрами необходимыми для выполнения.

2.  Данные получили. Теперь сводим с шаблоном:


        $page = new SkaTpl($file_path);
        $page->parseResponse($response, $parent);


где 

*$file_path* - путь к файлу шаблона,

*$response* - вышеописанный результат исполнения метода в виде массива,

*$parent* – jQuery-образный селектор элемента, в которой надо данные вставить.

<br>
##Описание методов

####setTemplate

    public function setTemplate (string $code)
    
**Описание:**

Установить шаблон для изменения.

**Параметры:**

-   *$code* – разметрка шаблона.

<br>
####getTemplate

    public function getTemplate ()
    
**Описание:**

Вернуть разметку обрабатываемого шаблона.

**Параметры:** нет.

<br>
####getLayers

    private function getLayers (string & $selector, array & $parents)
    
**Описание:**

Возвращает DOM-элементы для вставки.

**Параметры:**

-   *$selector* – селектор для поиска;

-   *$parents* – родительские элементы для поиска.

<br>
####getParents

    private function getParents (string $selector, array $parents = null)
    
**Описание:**

Возвращает все элементы шаблона для вставки.

**Параметры:**

-   *$selector* – селектор DOM-объекта;

-   *$parents* – элементы внутри которых следует искать объекты для вставки данных.

<br>
####getParent

    private function getParent (int & $startpos, array & $m, string & $tag, int & $index, string & $parent)
    
**Описание:**

Вхождение строк искомого селектора.

**Параметры:**

-   *$startpos* – с какой позиции искать;

-   *$m* – массив совпадений с селектором;

-   *$tag* – тег искомых элементов;

-   *$index* – счетчик вложенности поиска;

-   *$parent* – родительский элемент для поиска.

<br>
####insertRecord

    private function insertRecord (array & $record, string $parent)
    
**Описание:**

Вставить запись в элемент страницы.

**Параметры:**

-   *$record* – запись;

-   *$parent* – элемент для вставки.

<br>
####deleteCloneClass

    private function deleteCloneClass (string $parent)
    
**Описание:**

Удалить clone-класс из определения DOM-элемента.

**Параметры:**

-   *$parent* – DOM-элемент.

<br>
####insertData

    private function insertData (array & $data, array & $parents)
    
**Описание:**

Вставить данные в соответвтвующие элементы страницы.

**Параметры:**

-   *$data* – вставляемые данные;

-   *$parents* – массив элементов страницы для вставки.

<br>
####parseResponse

    public function parseResponse (array & $data, string & $selector)
    
**Описание:**

Вставить данные в шаблон и вернуть его.

**Параметры:**

-   *$data* – массив данных;

-   *$selector* – селектор элементов для вставки.
